use prelude
use core::collections
use core::errors
use core::signal
use core::string
use io::command
use io::dir
use io::path
use ffi::marshal

use cli
use manifest

extern system :: (command: *raw u8) -> i32

CliEvent :: struct
	id: u64,
	args: [String],

BuildRequestRecord :: struct
	id: u64,
	manifest_path: String,
	targets: [String],
	release: bool,
	show_help: bool,

BuildPlanRecord :: struct
	request_id: u64,
	request: BuildRequestRecord,
	manifest: PackageManifest,

BuildResultRecord :: struct
	request_id: u64,
	package_name: String,
	mode: String,
	success: bool,
	message: String,
	artifacts: [String],

PipelineError :: enum
	ManifestLoad :: struct
		path: String,
		message: String,
	CliParse :: struct
		message: String,

PipelineErrorEvent :: struct
	request_id: ?u64,
	error: PipelineError,

PipelineErrorRecord :: struct
	id: u64,
	request_id: ?u64,
	error: PipelineError,

CliEventsTable :: table
	@primary id: u64,
	args: [String],

BuildRequestsTable :: table
	@primary id: u64,
	manifest_path: String,
	targets: [String],
	release: bool,
	show_help: bool,

BuildPlansTable :: table
	@primary id: u64,
	request_id: u64,
	manifest: PackageManifest,

BuildResultsTable :: table
	@primary id: u64,
	request_id: u64,
	package_name: String,
	mode: String,
	success: bool,
	message: String,
	artifacts: [String],

PipelineErrorsTable :: table
	@primary id: u64,
	request_id: ?u64,
	error: PipelineError,

TripmRuntime :: @resource struct
	next_id: u64,
	manifest_root: String,

impl TripmRuntime:
	new :: (manifest_root: String) -> TripmRuntime => TripmRuntime {
		next_id: 1,
		manifest_root: manifest_root,
	}

	allocate_id :: (&mut self) -> u64 => do
		id := self.next_id
		self.next_id += 1
		ret id

	manifest_loader :: (&self) -> ManifestLoader =>
		ManifestLoader::new(String::clone(&self.manifest_root))

TripmDatabase :: db
	CliEvents: CliEventsTable,
	BuildRequests: BuildRequestsTable,
	BuildPlans: BuildPlansTable,
	BuildResults: BuildResultsTable,
	PipelineErrors: PipelineErrorsTable,
	Runtime: TripmRuntime,
	State: TripmDbState,


TripmDbState :: @resource struct
	cli_events: [CliEvent],
	build_requests: [BuildRequestRecord],
	build_plans: [BuildPlanRecord],
	build_results: [BuildResultRecord],
	pipeline_errors: [PipelineErrorRecord],

impl TripmDbState:
	new :: () -> TripmDbState => TripmDbState {
		cli_events: new [CliEvent],
		build_requests: new [BuildRequestRecord],
		build_plans: new [BuildPlanRecord],
		build_results: new [BuildResultRecord],
		pipeline_errors: new [PipelineErrorRecord],
	}
TripmBus :: @resource struct
	build_requests: Signal<BuildRequestRecord>,
	build_sender: SenderId,
	build_receiver: ReceiverId,

impl TripmBus:
	new :: () -> !TripmBus => do
		build_requests := Signal<BuildRequestRecord>::new(
			String::from_cstr("tripm.build_requests" as *u8),
			SignalTopology::MPSC,
			BufferingStrategy::FIFO { capacity: 32 },
		)
		build_sender := match build_requests.register_sender():
			ok sender_id => sender_id
			err err_ => do
				message := std_error_message(err_)
				println(String::from_cstr("[tripm] failed to initialize build request signal" as *u8))
				println(String::from_cstr("  message: " as *u8) + message)
				ret err err_
		build_receiver := match build_requests.register_receiver():
			ok receiver_id => receiver_id
			err err_ => ret err err_

		ret ok TripmBus {
			build_requests: build_requests,
			build_sender: build_sender,
			build_receiver: build_receiver,
		}

	emit_build_request :: (&mut self, request: BuildRequestRecord) -> !none =>
		self.build_requests.send(self.build_sender, request)

	next_build_request :: (&mut self) -> ?BuildRequestRecord =>
		self.build_requests.try_receive(self.build_receiver)

record_cli_event :: sys (
	runtime: res &mut TripmRuntime,
	db: res &mut TripmDbState,
	@sys_input args: [String],
) -> !u64 => do
	id := runtime.allocate_id()
	stored_args := clone_string_list(args)
	db.cli_events.push(CliEvent { id: id, args: stored_args })
	ret ok id

record_build_request :: sys (
	runtime: res &mut TripmRuntime,
	db: res &mut TripmDbState,
	bus: res &mut TripmBus,
	@sys_input manifest_path: String,
	@sys_input targets: [String],
	@sys_input release: bool,
	@sys_input show_help: bool,
) -> !BuildRequestRecord => do
	request_id := runtime.allocate_id()
	stored_targets := clone_string_list(targets)
	request := BuildRequestRecord {
		id: request_id,
		manifest_path: manifest_path,
		targets: stored_targets,
		release: release,
		show_help: show_help,
	}
	db.build_requests.push(clone_build_request(&request))
	match bus.emit_build_request(clone_build_request(&request)):
		ok none => none
		err err_ => ret err err_
	ret ok request

TripmPipelineTick :: Signal<Mpsc, Buffer, none>

poll_build_request :: sys (
	bus: res &mut TripmBus,
) -> !?BuildRequestRecord => do
	ret ok bus.next_build_request()

load_manifest_for_request :: sys (
	runtime: res &mut TripmRuntime,
	db: res &mut TripmDbState,
	@sys_input request: BuildRequestRecord,
) -> !?BuildPlanRecord => do
	loader := runtime.manifest_loader()
	manifest_result := loader.load(String::clone(&request.manifest_path))
	match manifest_result:
		ok manifest => do
			plan := BuildPlanRecord {
				request_id: request.id,
				request: clone_build_request(&request),
				manifest: manifest,
			}
			ret ok some plan
		err err_ => do
			message := std_error_message(err_)
			event := PipelineErrorEvent {
				request_id: some request.id,
				error: PipelineError::ManifestLoad {
					path: String::clone(&request.manifest_path),
					message: message,
				},
			}
			record := PipelineErrorRecord {
				id: runtime.allocate_id(),
				request_id: event.request_id,
				error: clone_pipeline_error(&event.error),
			}
			db.pipeline_errors.push(record)
			print_pipeline_error_event(event)
			ret ok none

prepare_manifest_outputs :: sys (
	db: res &mut TripmDbState,
	@sys_input plan: BuildPlanRecord,
) -> !BuildPlanRecord => do
	db.build_plans.push(clone_build_plan(&plan))
	print_plan_summary(clone_build_plan(&plan))
	ret ok plan

execute_build_plan_stage :: sys (
	@sys_input plan: BuildPlanRecord,
) -> !BuildResultRecord => do
	result := execute_build_plan(&plan)
	ret ok result

finalize_build_result :: sys (
	db: res &mut TripmDbState,
	@sys_input result: BuildResultRecord,
) -> !none => do
	db.build_results.push(clone_build_result(&result))
	print_build_result(result)
	ret ok none

drive_tripm_pipeline_once :: sys (
	runtime: res &mut TripmRuntime,
	db: res &mut TripmDbState,
	bus: res &mut TripmBus,
) -> !bool => do
	match poll_build_request(bus)?:
		some request => do
			match load_manifest_for_request(runtime, db, request)?:
				some plan => do
					prepared_plan := prepare_manifest_outputs(db, plan)?
					result := execute_build_plan_stage(prepared_plan)?
					finalize_build_result(db, result)?
					ret ok true
				none => ret ok true
		none => ret ok false

drive_tripm_pipeline :: sys (
	runtime: res &mut TripmRuntime,
	db: res &mut TripmDbState,
	bus: res &mut TripmBus,
) -> !none => do
	while true:
		processed := drive_tripm_pipeline_once(runtime, db, bus)?
		if not processed:
			break
	ret ok none

@trigger TripmPipelineTick, TripmDatabase
tripm_pipeline :: compose
	poll_build_request ?-> load_manifest_for_request -> prepare_manifest_outputs -> execute_build_plan_stage -> finalize_build_result


clone_string_list :: (source: [String]) -> [String] => do
	clone := new [String]
	for i in 0..source.len:
		match source.get(i):
			some value => do
				clone.push(String::clone(&value))
			none => do
				cont
	ret clone

clone_dependency_source :: (source: DependencySource) -> DependencySource => match source:
	DependencySource::Registry => DependencySource::Registry
	DependencySource::Git :: struct { reference } => DependencySource::Git { reference: String::clone(&reference) }
	DependencySource::Path :: struct { relative } => DependencySource::Path { relative: String::clone(&relative) }

clone_dependency_spec :: (spec: DependencySpec) -> DependencySpec => DependencySpec {
	name: String::clone(&spec.name),
	requirement: String::clone(&spec.requirement),
	source: clone_dependency_source(spec.source),
}

clone_dependency_list :: (specs: [DependencySpec]) -> [DependencySpec] => do
	clone := new [DependencySpec]
	for i in 0..specs.len:
		match specs.get(i):
			some entry => do
				clone.push(clone_dependency_spec(entry))
			none => do
				cont
	ret clone

clone_manifest :: (manifest: &PackageManifest) -> PackageManifest => PackageManifest {
	name: String::clone(&manifest.name),
	version: String::clone(&manifest.version),
	license: String::clone(&manifest.license),
	description: String::clone(&manifest.description),
	dependencies: clone_dependency_list(manifest.dependencies),
}

clone_build_request :: (source: &BuildRequestRecord) -> BuildRequestRecord => BuildRequestRecord {
	id: source.id,
	manifest_path: String::clone(&source.manifest_path),
	targets: clone_string_list(source.targets),
	release: source.release,
	show_help: source.show_help,
}

clone_build_plan :: (source: &BuildPlanRecord) -> BuildPlanRecord => BuildPlanRecord {
	request_id: source.request_id,
	request: clone_build_request(&source.request),
	manifest: clone_manifest(&source.manifest),
}

clone_build_result :: (source: &BuildResultRecord) -> BuildResultRecord => BuildResultRecord {
	request_id: source.request_id,
	package_name: String::clone(&source.package_name),
	mode: String::clone(&source.mode),
	success: source.success,
	message: String::clone(&source.message),
	artifacts: clone_string_list(source.artifacts),
}

clone_pipeline_error :: (source: &PipelineError) -> PipelineError => match *source:
	PipelineError::ManifestLoad :: struct { path, message } =>
		PipelineError::ManifestLoad {
			path: String::clone(&path),
			message: String::clone(&message),
		}
	PipelineError::CliParse :: struct { message } =>
		PipelineError::CliParse { message: String::clone(&message) }

execute_build_plan :: (plan: &BuildPlanRecord) -> BuildResultRecord => do
	mode := build_mode_label(plan.request.release)
	manifest_dir := manifest_directory_for_path(&plan.request.manifest_path)
	build_targets := determine_build_targets(&plan.request, &manifest_dir)
	relative_prefix := compute_relative_prefix(&manifest_dir)
	compiler_manifest := relative_prefix + String::from_cstr("tricti-compiler/Cargo.toml" as *u8)
	cd_dir := canonical_cd_directory(&manifest_dir)
	artifacts := new [String]
	success := true
	message := String::new()

	for i in 0..build_targets.len:
		match build_targets.get(i):
			some target => do
				command := build_compiler_command(&cd_dir, &compiler_manifest, &target, plan.request.release)
				preview := String::from_cstr("[tripm] run> " as *u8) + String::clone(&command)
				println(preview)
				exit_code := run_shell_command(command)
				if exit_code == 0:
					artifact_batch := collect_artifacts_for_target(&manifest_dir, &target)
					for j in 0..artifact_batch.len:
						match artifact_batch.get(j):
							some entry => do
								artifacts.push(entry)
							none => do
								cont
				else:
					success = false
					message = format_failure_message(&target, exit_code)
					break
			none => do
				cont

	if success:
		message = format_success_message(&plan.manifest.name, &build_targets)

	BuildResultRecord {
		request_id: plan.request_id,
		package_name: String::clone(&plan.manifest.name),
		mode: mode,
		success: success,
		message: message,
		artifacts: artifacts,
	}

print_plan_summary :: (plan: BuildPlanRecord) => do
	header := String::from_cstr("[tripm] manifest loaded" as *u8)
	println(header)

	request_id_str := String::from_u64(plan.request_id)
	println(String::from_cstr("  request-id: " as *u8) + request_id_str)
	println(String::from_cstr("  package: " as *u8) + plan.manifest.name)
	println(String::from_cstr("  version: " as *u8) + plan.manifest.version)
	println(String::from_cstr("  mode: " as *u8) + build_mode_label(plan.request.release))

	if plan.manifest.dependencies.len == 0:
		println(String::from_cstr("  dependencies: (none)" as *u8))
	else:
		println(String::from_cstr("  dependencies:" as *u8))
		for i in 0..plan.manifest.dependencies.len:
			match plan.manifest.dependencies.get(i):
				some dep => do
					line := format_dependency(dep)
					println(String::from_cstr("    - " as *u8) + line)
				none => do
					cont

print_pipeline_error :: (err_: PipelineError) => match err_:
	PipelineError::ManifestLoad :: struct { path, message } => do
		println(String::from_cstr("[tripm] manifest error" as *u8))
		println(String::from_cstr("  path: " as *u8) + path)
		println(String::from_cstr("  message: " as *u8) + message)
	PipelineError::CliParse :: struct { message } => do
		println(String::from_cstr("[tripm] cli parse error" as *u8))
		println(String::from_cstr("  message: " as *u8) + message)

print_pipeline_error_event :: (event: PipelineErrorEvent) => do
	println(String::from_cstr("[tripm] pipeline error" as *u8))
	match event.request_id:
		some id => println(String::from_cstr("  request-id: " as *u8) + String::from_u64(id))
		none => println(String::from_cstr("  request-id: (none)" as *u8))
	print_pipeline_error(event.error)

print_build_result :: (result: BuildResultRecord) => do
	println(String::from_cstr("[tripm] build result" as *u8))
	println(String::from_cstr("  request-id: " as *u8) + String::from_u64(result.request_id))
	println(String::from_cstr("  package: " as *u8) + result.package_name)
	println(String::from_cstr("  mode: " as *u8) + result.mode)
	if result.success:
		println(String::from_cstr("  status: success" as *u8))
	else:
		println(String::from_cstr("  status: failed" as *u8))
	println(String::from_cstr("  message: " as *u8) + result.message)
	if result.artifacts.len == 0:
		println(String::from_cstr("  artifacts: (none)" as *u8))
	else:
		println(String::from_cstr("  artifacts:" as *u8))
		for i in 0..result.artifacts.len:
			match result.artifacts.get(i):
				some artifact => do
					println(String::from_cstr("    - " as *u8) + artifact)
				none => do
					cont

run_shell_command :: (command: String) -> i32 => do
	c_command := marshal::string_to_cstr(command)
	status := system(c_command)
	marshal::free_cstr(c_command)
	ret status

manifest_directory_for_path :: (path: &String) -> String => do
	if path.len == 0:
		ret String::from_cstr("." as *u8)

	last_slash := -1i64
	for i in 0..path.len:
		if path.data[i] == 47:
			last_slash = i as i64

	if last_slash < 0:
		ret String::from_cstr("." as *u8)
	if last_slash == 0:
		ret String::from_cstr("." as *u8)

	dir := String::substring(path, 0, last_slash as u64)
	normalized := strip_leading_dot_slash(dir)
	if normalized.len == 0:
		ret String::from_cstr("." as *u8)
	if normalized.len == 1 and normalized.data[0] == 46:
		ret String::from_cstr("." as *u8)
	ret normalized

strip_leading_dot_slash :: (input: String) -> String =>
	if input.len >= 2 and input.data[0] == 46 and input.data[1] == 47:
		String::substring(&input, 2, input.len)
	else:
		input

is_root_directory :: (path: &String) -> bool =>
	path.len == 0 or (path.len == 1 and path.data[0] == 46)


determine_build_targets :: (request: &BuildRequestRecord, manifest_dir: &String) -> [String] => do
	tri_suffix := String::from_cstr(".tri" as *u8)
	toml_suffix := String::from_cstr(".toml" as *u8)
	targets := new [String]

	for i in 0..request.targets.len:
		match request.targets.get(i):
			some candidate => do
				if String::ends_with(&candidate, &toml_suffix):
					cont
				if String::ends_with(&candidate, &tri_suffix):
					targets.push(candidate)
			none => do
				cont

	if targets.len == 0:
		default_target := resolve_default_target(manifest_dir)
		targets.push(default_target)

	ret targets

resolve_default_target :: (manifest_dir: &String) -> String => do
	main_candidate := String::from_cstr("src/main.tri" as *u8)
	if manifest_relative_path_exists(manifest_dir, &main_candidate):
		ret main_candidate

	alt_candidate := String::from_cstr("src.tri" as *u8)
	if manifest_relative_path_exists(manifest_dir, &alt_candidate):
		ret alt_candidate

	ret String::from_cstr("src/main.tri" as *u8)

manifest_relative_path_exists :: (manifest_dir: &String, relative: &String) -> bool => do
	absolute := join_components(manifest_dir, relative)
	path_obj := Path::new(String::clone(&absolute))
	ret Path::exists(&path_obj)

join_components :: (left: &String, right: &String) -> String => do
	if is_root_directory(left):
		ret String::clone(right)

	result := String::clone(left)
	if result.len > 0 and result.data[result.len - 1] ~= 47:
		String::push_char(&result, 47)
	String::push_str(&result, right)
	ret result


compute_relative_prefix :: (dir: &String) -> String => do
	if is_root_directory(dir):
		ret String::new()

	segments := count_path_segments(dir)
	prefix := String::new()
	up := String::from_cstr("../" as *u8)
	for _ in 0..segments:
		String::push_str(&prefix, &up)
	ret prefix

count_path_segments :: (dir: &String) -> u64 => do
	if dir.len == 0:
		ret 0
	count := 1u64
	for i in 0..dir.len:
		if dir.data[i] == 47:
			count += 1
	ret count

canonical_cd_directory :: (dir: &String) -> String =>
	if is_root_directory(dir):
		String::from_cstr("." as *u8)
	else:
		String::clone(dir)


build_compiler_command :: (cd_dir: &String, compiler_manifest: &String, target: &String, release: bool) -> String => do
	command := String::from_cstr("cd " as *u8)
	String::push_str(&command, cd_dir)
	String::push_str(&command, &String::from_cstr(" && SKIP_STDLIB=0 cargo run --manifest-path " as *u8))
	String::push_str(&command, compiler_manifest)
	if release:
		String::push_str(&command, &String::from_cstr(" --release" as *u8))
	String::push_str(&command, &String::from_cstr(" -- " as *u8))
	String::push_str(&command, target)
	ret command


format_success_message :: (package_name: &String, targets: &[String]) -> String => do
	count := targets.len
	count_str := String::from_u64(count)
	message := String::from_cstr("Build completed for " as *u8) + String::clone(package_name)
	if count > 0:
		String::push_str(&message, &String::from_cstr(" (targets: " as *u8))
		joined := join_target_list(targets)
		String::push_str(&message, &joined)
		String::push_str(&message, &String::from_cstr(")" as *u8))
	String::push_str(&message, &String::from_cstr(" [" as *u8))
	String::push_str(&message, &count_str)
	String::push_str(&message, &String::from_cstr("]" as *u8))
	ret message

join_target_list :: (targets: &[String]) -> String => do
	joined := String::new()
	for i in 0..targets.len:
		if i > 0:
			String::push_str(&joined, &String::from_cstr(", " as *u8))
		match targets.get(i):
			some item => do
				String::push_str(&joined, &item)
			none => do
				cont
	ret joined

format_failure_message :: (target: &String, exit_code: i32) -> String => do
	message := String::from_cstr("Build failed for target " as *u8)
	String::push_str(&message, target)
	String::push_str(&message, &String::from_cstr(" (status " as *u8))
	code_str := String::from_i64(exit_code as i64)
	String::push_str(&message, &code_str)
	String::push_str(&message, &String::from_cstr(")" as *u8))
	ret message

ensure_build_directory :: (manifest_dir: &String) -> String => do
	build_segment := String::from_cstr("build" as *u8)
	build_path := join_components(manifest_dir, &build_segment)
	exists := io::dir::exists(String::clone(&build_path))
	if exists:
		ret build_path

	create_status := io::dir::create_dir(String::clone(&build_path))
	ret build_path

sanitize_target_name :: (target: &String) -> String => do
	sanitized := String::new()
	for i in 0..target.len:
		ch := target.data[i]
		if ch == 47 or ch == 92 or ch == 32:
			String::push_char(&sanitized, 95)
		else:
			String::push_char(&sanitized, ch)
	if sanitized.len == 0:
		ret String::from_cstr("target" as *u8)
	ret sanitized

collect_artifacts_for_target :: (manifest_dir: &String, target: &String) -> [String] => do
	results := new [String]
	build_dir := ensure_build_directory(manifest_dir)
	sanitized := sanitize_target_name(target)

	binary_name := String::from_cstr("output.out" as *u8)
	binary_suffix := String::from_cstr(".out" as *u8)
	binary_path := move_artifact_if_exists(manifest_dir, &build_dir, &binary_name, &sanitized, &binary_suffix)
	match binary_path:
		some final_path => do
			results.push(final_path)
		none => do
			source_path := join_components(manifest_dir, &binary_name)
			exists := io::dir::exists(String::clone(&source_path))
			if exists:
				results.push(source_path)

	object_name := String::from_cstr("output.o" as *u8)
	object_suffix := String::from_cstr(".o" as *u8)
	object_path := move_artifact_if_exists(manifest_dir, &build_dir, &object_name, &sanitized, &object_suffix)
	match object_path:
		some final_path => do
			results.push(final_path)
		none => do
			source_path := join_components(manifest_dir, &object_name)
			exists := io::dir::exists(String::clone(&source_path))
			if exists:
				results.push(source_path)

	ret results

move_artifact_if_exists :: (manifest_dir: &String, build_dir: &String, source_name: &String, sanitized: &String, suffix: &String) -> ?String => do
	source_path := join_components(manifest_dir, source_name)
	exists := io::dir::exists(String::clone(&source_path))
	if exists == false:
		ret none

	dest_filename := sanitized_with_suffix(sanitized, suffix)
	dest_path := join_components(build_dir, &dest_filename)
	remove_status := io::dir::remove_file(String::clone(&dest_path))
	renamed := io::dir::rename(String::clone(&source_path), String::clone(&dest_path))
	if renamed:
		ret some dest_path
	ret none

sanitized_with_suffix :: (sanitized: &String, suffix: &String) -> String => do
	combined := String::clone(sanitized)
	String::push_str(&combined, suffix)
	ret combined

format_dependency :: (spec: DependencySpec) -> String => match spec.source:
	DependencySource::Registry => spec.name + String::from_cstr(" (registry)" as *u8)
	DependencySource::Git :: struct { reference } => spec.name + String::from_cstr(" (git " as *u8) + reference + String::from_cstr(")" as *u8)
	DependencySource::Path :: struct { relative } => spec.name + String::from_cstr(" (path " as *u8) + relative + String::from_cstr(")" as *u8)

determine_manifest_path :: (targets: &[String]) -> String => do
	toml_suffix := String::from_cstr(".toml" as *u8)
	selected := String::from_cstr("Package.toml" as *u8)
	for i in 0..targets.len:
		match targets.get(i):
			some candidate => do
				if String::ends_with(&candidate, &toml_suffix):
					selected = String::clone(&candidate)
			none => do
				cont
	ret selected

build_mode_label :: (release: bool) -> String =>
	if release:
		String::from_cstr("release" as *u8)
	else:
		String::from_cstr("debug" as *u8)

render_generic_help :: () => do
	println(String::from_cstr("TriCTI Package Manager (tripm)" as *u8))
	println(String::from_cstr("Usage:" as *u8))
	println(String::from_cstr("  tripm build [targets] [--release]" as *u8))
	println(String::from_cstr("  tripm fetch" as *u8))
	println(String::from_cstr("  tripm init" as *u8))
	println(String::from_cstr("  tripm check" as *u8))

render_build_help :: () => do
	println(String::from_cstr("tripm build" as *u8))
	println(String::from_cstr("  --release    Produce optimized artifacts" as *u8))
	println(String::from_cstr("  --debug      Force debug build" as *u8))
	println(String::from_cstr("  targets      Optional build targets" as *u8))

render_pipeline_snapshot :: (db: &TripmDbState) => do
	println(String::from_cstr("[tripm] pipeline snapshot" as *u8))
	println(String::from_cstr("  cli-events: " as *u8) + String::from_u64(db.cli_events.len))
	println(String::from_cstr("  build-requests: " as *u8) + String::from_u64(db.build_requests.len))
	println(String::from_cstr("  build-plans: " as *u8) + String::from_u64(db.build_plans.len))
	println(String::from_cstr("  build-results: " as *u8) + String::from_u64(db.build_results.len))
	println(String::from_cstr("  errors: " as *u8) + String::from_u64(db.pipeline_errors.len))

run_build_command :: sys (
	runtime: res &mut TripmRuntime,
	db_: res &mut TripmDbState,
	bus: res &mut TripmBus,
	@sys_input targets: [String],
	@sys_input release: bool,
	@sys_input show_help: bool,
) -> !none => do
	if show_help:
		render_build_help()
		ret ok none

	request_targets := clone_string_list(targets)
	manifest_path := determine_manifest_path(&request_targets)
	match record_build_request(runtime, db_, bus, manifest_path, request_targets, release, show_help):
		ok request => do
			manifest_display := String::clone(&request.manifest_path)
			mode_label := build_mode_label(request.release)
			target_label := join_target_list(&request.targets)
			target_count := request.targets.len

			println(String::from_cstr("[tripm] enqueue build request" as *u8))
			println(String::from_cstr("  manifest: " as *u8) + manifest_display)
			println(String::from_cstr("  mode: " as *u8) + mode_label)
			if target_count == 0:
				println(String::from_cstr("  targets: (using src/main.tri)" as *u8))
			else:
				println(String::from_cstr("  targets: " as *u8) + target_label)
		err err_ => do
			message := std_error_message(err_)
			println(String::from_cstr("[tripm] build enqueue failed" as *u8))
			println(String::from_cstr("  message: " as *u8) + message)
			ret err err_

	ret ok none

current_project_root :: () -> String => String::from_cstr("." as *u8)

main :: () => do
	command_line := CommandLine::current()
	runtime := TripmRuntime::new(current_project_root())
	db_ := TripmDbState::new()
	bus := match TripmBus::new():
		ok value => value
		err err_ => do
			message := std_error_message(err_)
			println(String::from_cstr("[tripm] failed to initialize signals" as *u8))
			println(String::from_cstr("  message: " as *u8) + message)
			ret

	args := command_line.slice_from(0)
	match record_cli_event(&mut runtime, &mut db_, args):
		ok _ => none
		err err_ => do
			message := std_error_message(err_)
			println(String::from_cstr("[tripm] failed to record CLI event" as *u8))
			println(String::from_cstr("  message: " as *u8) + message)

	invocation := match CliInvocation::parse(command_line):
		ok parsed => parsed
		err err_ => do
			message := std_error_message(err_)
			event := PipelineErrorEvent {
				request_id: none,
				error: PipelineError::CliParse { message: message },
			}
			record := PipelineErrorRecord {
				id: runtime.allocate_id(),
				request_id: event.request_id,
				error: clone_pipeline_error(&event.error),
			}
			db_.pipeline_errors.push(record)
			print_pipeline_error_event(event)
			ret

	match invocation.command:
		CliCommand::Help => do
			render_generic_help()
		CliCommand::Fetch => do
			println(String::from_cstr("[tripm] fetch is not implemented yet" as *u8))
		CliCommand::Init => do
			println(String::from_cstr("[tripm] init is not implemented yet" as *u8))
		CliCommand::Check => do
			println(String::from_cstr("[tripm] check is not implemented yet" as *u8))
		CliCommand::Build :: struct { targets, release, show_help } => do
			match run_build_command(&mut runtime, &mut db_, &mut bus, targets, release, show_help):
				ok none => do
					match drive_tripm_pipeline(&mut runtime, &mut db_, &mut bus):
						ok none => none
						err err_ => do
							message := std_error_message(err_)
							println(String::from_cstr("[tripm] pipeline pump failed" as *u8))
							println(String::from_cstr("  message: " as *u8) + message)
							ret
				err err_ => do
					message := std_error_message(err_)
					println(String::from_cstr("[tripm] build command failed" as *u8))
					println(String::from_cstr("  message: " as *u8) + message)
					ret
		other => do
			println(String::from_cstr("[tripm] unsupported command" as *u8))
	render_pipeline_snapshot(&db_)
